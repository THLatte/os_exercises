#lec 3 SPOC Discussion

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
 1. 比较UEFI和BIOS的区别。
 1. 描述PXE的大致启动流程。

## 3.2 系统启动流程
 1. 了解NTLDR的启动流程。
 1. 了解GRUB的启动流程。
 1. 比较NTLDR和GRUB的功能有差异。
 1. 了解u-boot的功能。

## 3.3 中断、异常和系统调用比较
 1. 举例说明Linux中有哪些中断，哪些异常？
 1. Linux的系统调用有哪些？大致的功能分类有哪些？  (w2l1)

>  Linux的系统调用大约有200种左右或更多，功能大致分为进程控制、文件系统控制、系统控制、内存管理、网络管理、socket控制、用户管理、进程间通信等。

```
  + 采分点：说明了Linux的大致数量（上百个），说明了Linux系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
 1. 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？(w2l1)
 >  ucore的系统调用大约22个，大致分为进程控制（sys_fork、sys_exit等）、文件系统控制（sys_fsync、sys_fstat等）和系统控制（sys_gettime等）等。
 
 ```
  + 采分点：说明了ucore的大致数量（二十几个），说明了ucore系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.4 linux系统调用分析
 1. 通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(w2l1)
 
>  file用途为检测文件类型，对所得exe文件应用file命令获得：l1e0: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=d1c9294b45dbb8faf13e3db2d50aac427cafaad6, not stripped
>  nm命令用于显示关于对象文件、可执行文件以及对象文件库里的符号信息。对所得exe文件应用nm命令获得部分结果如下：
>  0000000000000002 a AF_INET
>  000000000060105c B __bss_start
>  000000000060105c b completed.6972
>  objdump用来显示一个或者多个目标文件的信息。使用选项控制具体显示哪些信息，例如-d可对文件进行反汇编。
>  Linux的系统调用需要首先根据请求的服务不同初始化各项参数，例如lab1-ex0.s中，将寄存器eax设为SYS_write，ebx设为STDOUT等，然后利用int 0x80命令中断来进行系统调用，完成所需的服务提供。

 ```
  + 采分点：说明了objdump，nm，file的大致用途，说明了系统调用的具体含义
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 
 ```
 
 1. 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(w2l1)
>  strace常用来跟踪进程执行时的系统调用和所接收的信号，包括参数、返回值、执行消耗的时间等。根据参数不同可以完成不同的功能。如题中所用参数-c即为统计每一系统调用的执行时间、调用次数和出错次数等。
>  应用触发系统调用的时候，首先将系统调用号填充到寄存器eax中，若有其他所需的参数也填入到相应的寄存器中，然后利用软中断命令int 0x80使系统切换到内核态并执行系统调用处理程序system_call()，其与硬件结构紧密相关，通常在entry.s文件中通过汇编语言编写。然后system_call()对eax中获取的系统调用号进行有效性检查，验证其有效后，利用这个调用号从存储了所有注册过的系统调用的列表sys_call_table中获取到对应的系统调用：以sys_call_table()为基址，加上%eax*4（列表中每个表项占用4字节）即获得了所需系统调用所在位置。

 ```
  + 采分点：说明了strace的大致用途，说明了系统调用的具体执行过程（包括应用，CPU硬件，操作系统的执行过程）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.5 ucore系统调用分析
 1. ucore的系统调用中参数传递代码分析。
 1. ucore的系统调用中返回结果的传递代码分析。
 1. 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
 1. 以ucore lab8的answer为例，尝试修改并运行代码，分析ucore应用的系统调用执行过程。
 
## 3.6 请分析函数调用和系统调用的区别
 1. 请从代码编写和执行过程来说明。
 1. 说明`int`、`iret`、`call`和`ret`的指令准确功能
 
